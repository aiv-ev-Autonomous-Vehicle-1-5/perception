# ROS 2 Component Container 실행 방식 비교: `component_container` vs `component_container_mt`

## 1. 개요
ROS 2의 Composable Node는 하나의 프로세스 안에서 여러 노드를 실행할 수 있어 효율적입니다. 하지만 이 노드들을 실행하는 **Executor(실행기)**의 종류에 따라 시스템의 동작 방식과 성능이 크게 달라집니다. 특히 연산량이 많은 노드(예: DBSCAN, Deep Learning)가 포함된 경우 올바른 컨테이너 선택이 필수적입니다.

## 2. `component_container` (SingleThreadedExecutor)

### 작동 방식
- **단일 스레드**: 프로세스 내에 오직 **하나의 스레드**만 존재합니다.
- **순차 실행 (Serial)**: 모든 노드의 콜백이 하나의 큐에 쌓이고, Executor가 이를 **하나씩 꺼내어 순서대로 실행**합니다.
- **블로킹 (Blocking)**: 현재 실행 중인 콜백이 완료될 때까지 다음 콜백은 대기해야 합니다.

### 문제점 (Bottleneck)
- **전체 파이프라인 지연**: 만약 DBSCAN 노드가 100ms 동안 연산을 수행한다면, 그 시간 동안 **다른 모든 노드(Driver, Transform 등)도 멈춥니다.**
- **데이터 유실 (Drop)**: LiDAR 데이터는 계속 들어오는데 Driver가 처리를 못 하므로, 입력 버퍼가 가득 차서 **센서 데이터가 유실**됩니다.
- **결과**: 전체 시스템의 Hz가 가장 느린 노드의 속도로 하향 평준화됩니다. (예: 10Hz 입력 → 0.2Hz 출력)

### 장점
- **단순함**: Race Condition(경쟁 상태)이나 Deadlock(교착 상태) 걱정이 없습니다.
- **디버깅 용이**: 실행 흐름이 예측 가능하여 디버깅이 쉽습니다.
- **낮은 오버헤드**: 컨텍스트 스위칭 비용이 적습니다.

---

## 3. `component_container_mt` (MultiThreadedExecutor)

### 작동 방식
- **멀티 스레드 (Thread Pool)**: 프로세스 내에 **여러 개의 스레드**를 생성합니다. (보통 CPU 코어 수만큼 자동 할당)
- **병렬 실행 (Parallel)**: 콜백이 발생하면 Executor가 **놀고 있는(Idle) 스레드**에 작업을 할당하여 동시에 여러 콜백을 실행합니다.
- **독립적 동작**: 하나의 노드가 오래 걸려도 다른 스레드에서 다른 노드의 콜백을 처리할 수 있습니다.

### 개선점 (Non-Blocking)
- **입력 처리 보장**: DBSCAN이 100ms 동안 계산 중이라도, **별도의 스레드에서 Driver가 LiDAR 데이터를 즉시 수신**하고 처리할 수 있습니다.
- **데이터 유실 방지**: 입력단(Driver)이 막히지 않으므로 센서 데이터 손실이 없습니다.
- **성능 최적화**: 멀티코어 CPU 자원을 최대한 활용하여 전체 처리량을 높입니다.

### 주의할 점
- **Thread Safety**: 전역 변수나 공유 자원에 접근할 때 `mutex` 등으로 동기화 처리가 필요합니다. (각 노드가 독립적이라면 보통 문제없음)
- **CPU 사용량 증가**: 스레드 관리 및 컨텍스트 스위칭 오버헤드가 발생합니다.

---

## 4. 결론: 왜 `_mt`를 써야 하는가?

| 특징 | `component_container` | `component_container_mt` |
| :--- | :--- | :--- |
| **스레드 수** | 1개 | 여러 개 (CPU 코어 수 기반) |
| **실행 방식** | 순차 실행 (앞 작업 끝나야 뒷 작업) | 병렬 실행 (동시에 여러 작업) |
| **블로킹** | **취약함** (무거운 노드가 전체 마비) | **강함** (무거운 노드 있어도 다른 노드 동작) |
| **적합한 경우** | 가벼운 노드들, 순서가 중요한 경우 | **무거운 연산(DBSCAN, DL)이 섞여 있는 경우** |

**DBSCAN처럼 연산 비용이 높은 노드가 파이프라인에 포함될 때는, 전체 시스템이 느려지는 것을 막기 위해 반드시 `component_container_mt` (멀티스레드)를 사용해야 합니다.**
