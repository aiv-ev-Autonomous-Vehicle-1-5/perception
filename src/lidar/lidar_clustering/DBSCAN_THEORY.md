# DBSCAN 알고리즘 이론

## 핵심 개념 3가지

### 1. 코어 포인트 (Core Point)
- 반경 `eps` 안에 이웃이 `min_pts`개 이상인 포인트
- 클러스터의 "내부"를 구성

### 2. 보더 포인트 (Border Point)
- 자기 자신은 코어가 아니지만, 어떤 코어 포인트의 eps 범위 안에 들어가는 포인트
- 클러스터의 "가장자리"

### 3. 노이즈 (Noise)
- 어떤 코어 포인트의 eps 범위에도 들어가지 못한 포인트
- 어디에도 속하지 않음, label = -1

```
eps = 1m, min_pts = 3 일 때:

      · ← 노이즈 (주변에 아무도 없음)

   ○ ○ ○ ○    ← 코어들 (서로 eps 내에 3개 이상)
     ·         ← 보더 (코어 옆이지만 자기 이웃은 부족)
```

---

## 알고리즘 단계

### 1단계: 이웃 탐색

모든 포인트에 대해 반경 `eps` 내의 이웃 수를 센다.

```
포인트 P에 대해:
  eps 반경 안의 모든 포인트를 찾음
  이웃 수 >= min_pts → P는 코어 포인트
  이웃 수 <  min_pts → P는 코어가 아님 (보더 또는 노이즈 후보)
```

이 단계가 **전체 알고리즘에서 가장 비용이 크다.** 단순하게 하면 모든 포인트 쌍을 비교해야 해서 O(N²). 이걸 줄이기 위해:

- **CPU**: KD-Tree → 공간 분할 트리로 탐색 범위 축소
- **GPU**: 3D 그리드 셀 → 인접 27개 셀만 탐색

### 2단계: 클러스터 확장

코어 포인트끼리 eps 이내이면 **같은 클러스터로 연결**한다.

```
코어 A ──eps 이내──> 코어 B → 같은 클러스터
코어 B ──eps 이내──> 코어 C → 같은 클러스터
∴ A, B, C 모두 같은 클러스터
```

이것은 **연결 요소(Connected Component)** 문제다. 코어 포인트를 노드로, eps 이내 관계를 간선으로 보면 그래프의 연결 요소를 찾는 것과 같다.

- **CPU**: BFS(너비 우선 탐색) — 하나의 코어에서 시작해서 연결된 코어를 큐로 확장
- **GPU**: DSU(Disjoint Set Union) — 모든 코어가 동시에 이웃과 union, atomicCAS로 동시성 보장

### 3단계: 보더 포인트 흡수

코어가 아닌 포인트 중 코어의 eps 범위 안에 있으면 해당 클러스터에 편입시킨다.

```
코어 A (클러스터 0)
  └─ eps 이내 ─→ 보더 Q → Q도 클러스터 0에 편입
```

### 4단계: 나머지 = 노이즈

어떤 클러스터에도 편입되지 못한 포인트는 노이즈(-1)로 남는다.

---

## CPU vs GPU 구현 차이

같은 DBSCAN이지만 **2단계의 접근법**이 근본적으로 다르다.

### CPU — 순차적 BFS

```
미방문 포인트 중 코어 P를 하나 고른다
  → P를 새 클러스터의 시작으로 설정
  → P의 이웃들을 큐에 넣는다
  → 큐에서 하나씩 꺼내며:
      코어면 → 그 이웃도 큐에 추가 (확장)
      코어 아니면 → 편입만 하고 확장 안 함
  → 큐가 비면 클러스터 완성
다음 미방문 코어로 이동, 반복
```

한번에 **하나의 클러스터**를 완성한 뒤 다음으로 넘어간다. 순차적.

### GPU — 동시 DSU

```
모든 포인트를 각각 독립 집합으로 초기화: labels[i] = i
모든 코어 포인트가 동시에:
  자기 eps 이내 이웃을 찾아 union(나, 이웃)
  → atomicCAS로 작은 인덱스를 루트로 설정
모든 union 완료 후:
  경로 압축 → 모든 포인트가 직접 루트를 가리킴
  코어를 포함한 트리 = 클러스터
  코어 없는 트리 = 노이즈
```

**모든 클러스터가 동시에** 형성된다. BFS 같은 순차적 확장이 없다.

---

## 이웃 탐색 가속 구조 비교

### KD-Tree (CPU)

```
         [중앙값으로 분할]
           /         \
      좌측 공간     우측 공간
       /    \        /    \
     ...    ...    ...    ...
```

- 이진 트리로 공간을 재귀적으로 분할
- 탐색: 트리를 타고 내려가며 불필요한 가지 가지치기 (pruning)
- **장점**: 포인트 분포에 적응적, 어떤 분포든 효율적
- **단점**: 재귀적 → GPU 병렬화에 부적합

### 3D 그리드 (GPU)

```
┌──┬──┬──┬──┐
│  │  │  │  │  ← eps 크기로 균일 분할
├──┼──┼──┼──┤
│  │ P│  │  │  ← P의 이웃은 P가 속한 셀 + 인접 26개 셀에만 존재
├──┼──┼──┼──┤
│  │  │  │  │
└──┴──┴──┴──┘
```

- 공간을 eps 크기 셀로 균일 분할
- 이웃 후보 = 자기 셀 + 인접 26개 = 최대 27개 셀
- **장점**: 각 포인트가 독립적으로 이웃 탐색 가능 → GPU 병렬화에 완벽
- **단점**: 포인트가 한곳에 몰리면 특정 셀에 집중 → O(N²) 퇴화

---

## DSU (Disjoint Set Union) 이론

클러스터 병합에 사용되는 자료구조.

```
초기 상태: 각자 자기가 루트
[0] [1] [2] [3] [4]

union(0, 1): 1의 루트를 0으로
[0→0] [1→0] [2] [3] [4]

union(2, 3): 3의 루트를 2로
[0→0] [1→0] [2→2] [3→2] [4]

union(1, 3): 루트 0과 루트 2를 비교, 큰 쪽(2)을 작은 쪽(0)에 연결
[0→0] [1→0] [2→0] [3→2→0] [4]

경로 압축 후:
[0→0] [1→0] [2→0] [3→0] [4]
→ 0,1,2,3은 클러스터 0 / 4는 노이즈
```

GPU에서는 여러 스레드가 동시에 union을 시도하므로, `atomicCAS`(Compare-And-Swap)로 충돌을 해결한다:
- "이 값이 아직 X이면 Y로 바꿔라"를 원자적으로 실행
- 다른 스레드가 먼저 바꿨으면 실패 → 재시도

---

## 요약

| 단계 | 하는 일 | 핵심 질문 |
|---|---|---|
| 이웃 탐색 | eps 내 이웃 수 세기 | 누가 코어인가? |
| 클러스터 확장 | 코어끼리 연결 | 어떤 코어들이 하나의 덩어리인가? |
| 보더 흡수 | 비코어를 인접 클러스터에 편입 | 가장자리 포인트는 어디 소속인가? |
| 노이즈 분류 | 나머지 = 노이즈 | 아무데도 못 들어간 건? |
